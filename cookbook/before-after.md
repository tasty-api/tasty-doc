# Подготовка данных для теста (before & after test processing)
Иногда данные необходимые для теста - неизвестны и мы не можем протестировать ресурс случайным набором значений, примером может служить идентификатор продукта. Этот продукт должен существовать в системе, которая в данный момент тестируется. На этот случай у нас есть два варианта:

1. Запросить данные с другого ресурса, и сохранить их в памяти для дальнейшего использования в тесте (либо в другом подготовительном запросе, который уже вернёт необходимые данные для теста)
2. Создать данные при помощи соответствующего endpoint’а системы, с этими данными провести тест и удалить эти данные при помощи противоположного endpoint’а системы, который данную функциональность реализует. Другими словами, нам нужно подготовить данные для теста, выполнить тест и подчистить за собой.

Атрибуты метода case, начиная с третьего соответствуют либо:

- вызовам api методов приложения (которые служат для целей описанных выше) либо сторонних сервисов (с аналогичной целью)
- вызовам методов `test` и `tests` (для тестирования как такового)
- и опять вызовам api методов тестируемого приложения либо стороннего сервиса

Атрибуты идут в хронологическом порядке, слева направо (или сверху вниз, в зависимости от стиля написания) и все вызовы сторонних сервисов и методов самого приложения идущие до какого либо теста как и ожидается - выполняются до этого теста - синхронно (даже несмотря на то что все эти операции асинхронные) в дальнейшем будут детально рассмотрены методы `parallel` и `series` которые явно задают характер выполнения подобных вызовов.

Тесты так же выполняются последовательно, один за другим.

Всё что находится после последнего теста, неожиданно выполняется после этого теста (как слышится - так и пишется) - это самое место, для того чтобы подчистить за собой и удалить созданные объекты в системе после прохождения тестов.

## Рассмотрим конкретный пример
Мы будем тестировать post метод endpoint'а приложения, который в body принимает id продукта и его количество и возвращает общий вес набора.

```js
tasty.case(
  'get products weight', null,
);
```
Для тестирования нам необходимо знать некоторый id продукта, которые существует в тестируемой системе.
Получим его при помощи get метода приложения products, в ответе метода мы ожидаем получить массив продуктов - возьмём первый попавшийся.

```js
tasty.case(
  'get products weight', null,
  app.products.get({
    capture: {
      json: '$.0.id',
      as: 'productId',
    },
  }),
);
```

Опция `capture` указывает Tasty захватить значение по определённому в json параметре пути (это json path, $ тут означает корень объекта и соответствует данным пришедшим в ответ от сервера) с указанным именем `productId`, в дальнейшем мы сможем ссылаться на это значение при помощи строковых шаблонов (`${productId}`) там где нам нужно будет использовать это значение.

Напишем сам тест, который берёт этот идентификатор, подставляет в проверяемый метод `calcWeight` и проверяет код ответа (он должен быть 200) и структуру ответа (её мы описали на этапе декларации метода)

```js
tasty.case(
  'get products weight', null,
  app.products.get({
    capture: {
      json: '$.0.id',
      as: 'productId',
    },
  }),
  tasty.test(
    'calculate weight by product id and quantity',
    app.calcWeight.post({
      body: [{
        productId: '${productId}',
        quantity: 8,
      }],
    }),
    {
      checkStatus: 200,
      checkStructure: app.calcWeight.getSchema('success'),
    },
  ),
);
```

That’s it!

Аналогично, мы могли бы создать продукт, провести с ним тест и удалить из системы по завершении тестирования.

Посмотрим на примере:

```js
tasty.case(
  'get products weight', null,
  app.products.post({
    body: { name: 'Кирпич', weight: 8 },
    capture: {
      json: '$.id',
      as: 'productId',
    },
  }),
  tasty.test(
    'calculate weight by product id and quantity',
    app.calcWeight.post({
      body: [{
        productId: '${productId}',
        quantity: 8,
      }],
    }),
    {
      checkStatus: 200,
      checkStructure: app.calcWeight.getSchema('success'),
    },
  ),
  app.products
    .setPath('${productId}')
    .delete(),
);
```

Теперь мы готовы писать сколь угодно сложные тесты для многогранного внешнего мира нашего приложения.
