# Getting Started

Корень приложения содержит две важные дирректории:
- app
- test

##app

В дирректории app содержится экземпляр тестируемого приложения.
В файле ```app/index.js``` необходимо сконфигурировать приложение.
Константа ```APP_NAME``` содержит название приложения (или ID канала)
Конструктор ```App(channelId, channelOptions)``` вторым аргументом принимает опции для приложения:
- host - список хостов приложения по средам
  - develop - среда разработки
  - testing - среда тестирования (или pre-prod)
  - product - продуктовая среда (или prod)
- trace - список хостов tracing сервиса
  - develop - tracing для разработки
  - testing - тестовый tracing (или pre-prod)
  - product - продуктовый tracing (или prod)

Дирректория ```app/endpoints``` содержит произвольную, вложенную структуру папок, которые могут содержать файлы декларации endpoint'а ```app/endpoints/**/index.js```
Внутри этого каталога необходимо один раз задекларировать endpoint для его дальнейшего использования в тестах.
```javascript
const app = require('@/app'); // импорт экземпляра приложения

app.declare({
  url: 'адрес для эндпоинта',
  alias: 'короткое имя для эндпоинта',
  methods: ['get', 'post'], // массив методов для эндпоинта
  headers: {
      'имя заголовка по умолчанию': 'значение заголовка по умолчанию',
  },
  params: {
      'имя параметра по умолчанию': 'значение параметра по умолчанию',
  },
  body: 'тело запроса по умолчанию',
  schemas: {
      'имя схемы': require('./schemas/названия файла с опианием схемы'),
  },
  mock: 'объект которым эмитируется ответ сервера',
})
```
Схемы характерные для конкретного endpoint'а рекомендуется хранить в каталоге соответствующего endpoint'a в подкаталоге schemas, в отдельных файлах (для описания схемы используется библиотека Joi).

В файле ```app/data.js``` содержатся данные по средам для единообразного использования в декларациях либо тестах.

##test
Каталог ```test``` содержит два подкаталога
- func - функциональные тесты
- load - нагрузочные тесты

Структура каталогов - произвольная, с неограниченной вложенностью. Но внутри каталогов должны лежать только файлы тестов.

Для написания теста, необходимо импортировать приложение и фреймворк

```javascript
const app = require('@/app');
const { tasty } = require('tasty-api');
```

Далее, используя метод ```tasty.case``` описать сам тестовый кейс. Результат метода необходимо экспортировать использую присваивание (```module.exports = tasty.case```)
Первым аргументом идёт строка - это заголовок кейса.

Если для выполнения теста, необходимы данные, которых изначально нет (к примеру полуить из результата запроса) в названии файла необходимо указать постфикс .prep.js
В этом случае аргументом идёт подготовительная функция tasty.prepare(...actions), которая принимает последовательность запросов, которые необходимо выполнить до начала тестирования как такового (это стадия инициализации и важно не путать эту стадию с секцией before)

В случае когда начальная инициализация ненужна, вторым аргументом достаточно передать ```null```

Далее идут действия, которые могут быть двух типов:
- запрос
- тест

Все действия выполняются в том порядке, в котором они были описаны. Для управления запросами доступны функции tasty.series для выполнения запросов последовательно (поведение по умолчанию) tasty.parallel для выполнения запросов параллельно.

Все опции запроса могу меняться в процессе, либо вызовами методов ресурса:
- setHeaders
- setParams
- setBody
- setMock

Либо в виде объекта переданного функции методу
```javascript
app.loagin.post({
    headers: {},
    params: {},
    body: {},
    mock: {},
});
```

Так же объект опций метода может содержать поле capture для получения данных из ответа, и сохранения его в переменную для дальнейшего использования.
Фармат объекта следующий:
```json
{
    "json": "$.путь.до.свойства.в.объекте.ответа",
    "as": "имя_переменной"
}
```

Сам тест описывается при помощи метода tasty.test
Первым аргументом метод принимает название теста
Вторым - запрос к ресурсу который будет тестироваться
Третьим - объект с проверками
```javascript
{
  checkStatus: 200,
  checkStatusText: 'OK',
  checkStructure: app.login.getSchema('authSuccess'),
  check: (res) => {} // Функция провверки, должна вернуть либо true (проверка прошла) либо false (проверка не прошла)
}
```
После тестов так же могут быть выполнены методы приложения (app.logout.post()).

В случае нагрузочного теста, порядок действий аналогичен, одно отличие метод tasty.test здесь избыточен и сам кейс по факту должен содержать только последовательность выполняемых запросов которая должна быть проверена под нагрузкой.
